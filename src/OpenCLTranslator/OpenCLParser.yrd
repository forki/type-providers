{
open Brahma.FSharp.OpenCL.AST
}

info {
    C99 keywords:
        auto break case char const continue default do double else enum extern
        float for goto if inline int long register restrict return short signed
        sizeof static struct switch typedef union unsigned void volatile while
        _Bool _Complex _Imaginary
    OpenCL C 2.0 keywords:
        Data types: (see below)
        Address space qualifiers:
            __global global __local local
            __constant constant __private private
            __generic generic (* reserved *)
        Function qualifiers:
            __kernel kernel
        Access qualifiers:
            __read_only read_only __write_only write_only __read_write read_write
        Additional:
            uniform pipe
}

tokens {
    _ of string
}

options {
    translate = true
    module = "OpenCLTranslator.Parser"
    infEpsPath = epsilons
    pos = uint64
}

module Main

[<Start>]
program: (* FunDecl list *)
    function_definition+

(* TODO *)
function_definition: (* FunDecl *)
    specifs=declaration_specifier_list decl=declarator ';' {
        (* TODO for decl: match with ident(arg list) *)
        FunDecl<_>(
            isKernel:bool=, (* TODO: mebby change this in AST *)
            name:string,
            retType:Type<'lang>,
            args:List<FunFormalArg<'lang>>,
            body=StatementBlock<_>([])
        )

    }
    (* declaration_specifier+ declarator declaration* compound_statement *)
    (* Declararion list between function header and body is not supported; body is filtered during lexing and omitted *)

(* Declaration specifiers *)

(* TODO *)
declaration_specifier_list: (* DeclSpecifierPack *)


(* TODO *)
declaration_specifier:
    function_qualifier
    | address_space_qualifier
    | access_qualifier
    | storage_class_specifier
    | type_specifier
    | type_qualifier

function_qualifier: (* FunQualifier *)
    KERNEL { Kernel }
    (* omitted: __attribute__ qualifiers *)

address_space_qualifier: (* AddressSpaceQualifier *)
    GLOBAL { Global }
    | LOCAL { Local }
    | CONSTANT { Constant }
    | PRIVATE { Private }

access_qualifier: (* AccessQualifier *)
    READ_ONLY { ReadOnly }
    | WRITE_ONLY { WriteOnly }
    | READ_WRITE { ReadWrite }

storage_class_specifier: (* StorageClassSpecifier *)
    TYPEDEF { failwith "Fatal: typedef not supported yet!" }
    | EXTERN { Extern } (* only for functions and global variables declared in program scope or variables declared inside a function *)
    | STATIC { Static } (* only for non-kernel functions, global variables declared in program scope and variables inside a function declared in the global or constant address space *)

type_specifier: (* Type *)
    BOOL { PrimitiveType<_>(Bool) }
    | CHAR { PrimitiveType<_>(Char) } | SHORT { PrimitiveType<_>(Short) }
    | INT { PrimitiveType<_>(Int) } | LONG { PrimitiveType<_>(Long) }
    | UCHAR { PrimitiveType<_>(UChar) } | USHORT { PrimitiveType<_>(UShort) }
    | UINT { PrimitiveType<_>(UInt) } | ULONG { PrimitiveType<_>(ULong) }
    | FLOAT { PrimitiveType<_>(Float) } | DOUBLE { PrimitiveType<_>(Double) } | HALF { PrimitiveType<_>(Half) }
    | SIGNED t=type_specifier {
        match t with
        | t when t :? PrimitiveType<_> ->
            match (t :?> PrimitiveType<_>).Type with
            | Char | Short | Int | Long -> t
            | _ -> failwithf "Fatal: could not parse 'signed %s'" t.ToString() |> ToLower
    }
    | UNSIGNED t=type_specifier {
        match t with
        | t when t :? PrimitiveType<_> ->
            match (t :?> PrimitiveType<_>).Type with
            | Char -> UChar
            | Short -> UShort
            | Int -> UInt
            | Long -> ULong
            | _ -> failwithf "Fatal: could not parse 'unsigned %s'" t.ToString() |> ToLower
    }
    (* | SIZE_T | PTRDIFF_T | INTPTR_T | UINTPTR_T *)
    | VOID { PrimitiveType<_>(Void) }
    (* | CHAR2 | UCHAR2 | SHORT2 | USHORT2 | INT2 | UINT2 | LONG2 | ULONG2 | FLOAT2 | DOUBLE2
    | CHAR3 | UCHAR3 | SHORT3 | USHORT3 | INT3 | UINT3 | LONG3 | ULONG3 | FLOAT3 | DOUBLE3
    | CHAR4 | UCHAR4 | SHORT4 | USHORT4 | INT4 | UINT4 | LONG4 | ULONG4 | FLOAT4 | DOUBLE4
    | CHAR8 | UCHAR8 | SHORT8 | USHORT8 | INT8 | UINT8 | LONG8 | ULONG8 | FLOAT8 | DOUBLE8
    | CHAR16 | UCHAR16 | SHORT16 | USHORT16 | INT16 | UINT16 | LONG16 | ULONG16 | FLOAT16 | DOUBLE16 *)
    (* | IMAGE2D_T | IMAGE3D_T | IMAGE2D_ARRAY_T | IMAGE1D_T
    | IMAGE1D_BUFFER_T | IMAGE1D_ARRAY_T | IMAGE2D_DEPTH_T | IMAGE2D_ARRAY_DEPTH_T *)
    (* | SAMPLER_T | QUEUE_T | NDRANGE_T
    | CLK_EVENT_T | RESERVE_ID_T | EVENT_T
    | CL_MEM_FENCE_FLAGS *)
    | t=TYPE_NAME { PrimitiveType<_>(TypeName t) }
    | s=struct_or_union_specifier { StructType<_>(Some s) }
    (* | enum_specifier *)
    (* omitted: reserved data types (OpenCL C 2.0, section 6.1.4) *)

type_qualifier: (* TypeQualifier *)
    CONST { Const }
    | RESTRICT { Restrict }
    | VOLATILE { Volatile }

(* `inline` function specifier is not supported in OpenCL C; see http://code.opencv.org/issues/3746 *)

(* Declarator *)

declarator: (* ((Type -> Type) option, string) *)
    pcl=pointer? (dcl, ident)=direct_declarator {
        match pcl, dcl with
        | None,     None     -> None, ident
        | Some pcl, None     -> pcl, ident
        | None,     Some dcl -> dcl, ident
        | Some pcl, Some dcl -> pcl <| dcl, ident
    }
(* NB: test the examples from C99, 6.7.5.1.3 at page 115 *)

direct_declarator: (* ((Type -> Type) option, string) *)
    ident=IDENTIFIER { None, ident }
    | (cl, ident)=direct_declarator '[' ']' {
        match cl with
        | None -> fun t -> ArrayType<_>(t), ident
        | Some cl -> fun t -> ArrayType<_>(cl t), ident
    }
    | (cl, ident)=direct_declarator '(' parameter_list? ')' {

    }
    (* | '(' d=declarator ')'
    | direct_declarator '(' identifier_list? ')' *)

pointer: (* Type -> Type *)
    '*' qs=type_qualifier_list? cl=pointer? {
        match cl with
        | None -> fun t -> RefType<_>(t, qs)
        | Some cl -> fun t -> RefType<_>(cl t, qs)
    }

type_qualifier_list: (* TypeQualifier list *)
    type_qualifier+

parameter_list: (* FunFormalArg list *)
    not_empty_comma_list<parameter_declaration>

parameter_declaration: (* FunFormalArg *)
    declSpecs=declaration_specifier_list (cl, ident)=declarator {
        match cl with
        | None -> FunFormalArg<_>(declSpecs, ident)
        | Some cl ->
            match declSpecs.Type with
            | Some oldType ->
                let newType = cl oldType
                let newDeclSpecs = new DeclSpecifierPack<_>(declSpecs.FunQual,
                                                            declSpecs.AddressSpaceQual,
                                                            declSpecs.AccessQual,
                                                            declSpecs.StorageClassSpec,
                                                            newType,
                                                            declSpecs.TypeQual)
                FunFormalArg<_>(declSpecs, ident)
            | None -> failwithf "Fatal: no type definition found for %s" ident
    }
    (* | declaration_specifier+ *)

(* identifier_list:
    not_empty_comma_list<IDENTIFIER> *)

(* Declaration *)

(* declaration:
    declaration_specifier+ init_declarator_list? ';'

init_declarator_list:
    not_empty_comma_list<init_declarator>

init_declarator:
    declarator *)

(* Struct-or-union specifier (used in type_specifier) *)

struct_or_union_specifier: (* Struct *)
    struct_or_union n=IDENTIFIER { Struct<_>(n, []) }

struct_or_union: (* unit *)
    STRUCT
    (* | UNION *)

(* Enum specifier (used in type_specifier) *)

(* enum_specifier:
    ENUM IDENTIFIER
    | ENUM IDENTIFIER? '{' enumerator_list ','? '}'

enumerator_list:
    not_empty_comma_list<enumerator>

enumerator:
    IDENTIFIER *)

(* Common *)

not_empty_comma_list<item>: (* item list *)
    h=item t=(',' item)* { h :: [for (_, it) in t -> it] }
