{
open Brahma.FSharp.OpenCL.AST
}

info {
    C99 keywords:
        auto break case char const continue default do double else enum extern
        float for goto if inline int long register restrict return short signed
        sizeof static struct switch typedef union unsigned void volatile while
        _Bool _Complex _Imaginary
    OpenCL C 2.0 keywords:
        Data types: (see below)
        Address space qualifiers:
            __global global __local local
            __constant constant __private private
            __generic generic (* reserved *)
        Function qualifiers:
            __kernel kernel
        Access qualifiers:
            __read_only read_only __write_only write_only __read_write read_write
        Additional:
            uniform pipe
}

tokens {
    _ of string
}

options {
    translate = true
    module = "OpenCLTranslator.Parser"
    infEpsPath = epsilons
    pos = uint64
}

module Main

[<Start>]
program:
    function_definition+

function_definition:
    declaration_specifier+ declarator declaration* ';' (* semicolon instead of compound_statement *)

(* Declaration specifiers *)

declaration_specifier:
    function_qualifier
    | address_space_qualifier
    | access_qualifier
    | storage_class_specifier
    | type_specifier
    | type_qualifier
    | function_specifier

function_qualifier:
    KERNEL
    (* omitted: __attribute__ qualifiers *)

address_space_qualifier:
    GLOBAL
    | LOCAL
    | CONSTANT
    | PRIVATE

access_qualifier:
    READ_ONLY
    | WRITE_ONLY
    | READ_WRITE

storage_class_specifier:
    TYPEDEF
    | EXTERN (* only for functions and global variables declared in program scope or variables declared inside a function *)
    | STATIC (* only for non-kernel functions, global variables declared in program scope and variables inside a function declared in the global or constant address space *)

type_specifier:
    BOOL | CHAR | SHORT | INT | LONG
    | UCHAR | USHORT | UINT | ULONG
    | SIGNED | UNSIGNED
    | SIZE_T | PTRDIFF_T | INTPTR_T | UINTPTR_T
    | VOID
    | CHAR2 | UCHAR2 | SHORT2 | USHORT2 | INT2 | UINT2 | LONG2 | ULONG2 | FLOAT2 | DOUBLE2
    | CHAR3 | UCHAR3 | SHORT3 | USHORT3 | INT3 | UINT3 | LONG3 | ULONG3 | FLOAT3 | DOUBLE3
    | CHAR4 | UCHAR4 | SHORT4 | USHORT4 | INT4 | UINT4 | LONG4 | ULONG4 | FLOAT4 | DOUBLE4
    | CHAR8 | UCHAR8 | SHORT8 | USHORT8 | INT8 | UINT8 | LONG8 | ULONG8 | FLOAT8 | DOUBLE8
    | CHAR16 | UCHAR16 | SHORT16 | USHORT16 | INT16 | UINT16 | LONG16 | ULONG16 | FLOAT16 | DOUBLE16
    | IMAGE2D_T | IMAGE3D_T | IMAGE2D_ARRAY_T | IMAGE1D_T
    | IMAGE1D_BUFFER_T | IMAGE1D_ARRAY_T | IMAGE2D_DEPTH_T | IMAGE2D_ARRAY_DEPTH_T
    | SAMPLER_T | QUEUE_T | NDRANGE_T
    | CLK_EVENT_T | RESERVE_ID_T | EVENT_T
    | CL_MEM_FENCE_FLAGS (* omitted: reserved data types (OpenCL C 2.0, section 6.1.4) *)
    | TYPE_NAME | struct_or_union_specifier | enum_specifier

type_qualifier:
    CONST
    | RESTRICT
    | VOLATILE

function_specifier:
    INLINE

(* Declarator *)

declarator:
    pointer? direct_declarator

direct_declarator:
    IDENTIFIER
    | '(' declarator ')'
    | direct_declarator '[' ']'
    | direct_declarator '(' parameter_list ')'
    | direct_declarator '(' identifier_list? ')'

pointer:
    '*'
    | '*' type_qualifier+
    | '*' pointer
    | '*' type_qualifier+ pointer

parameter_list:
    not_empty_comma_list<parameter_declaration>

parameter_declaration:
    declaration_specifier+ declarator
    | declaration_specifier+

identifier_list:
    not_empty_comma_list<IDENTIFIER>

(* Declaration *)

declaration:
    declaration_specifier+ init_declarator_list? ';'

init_declarator_list:
    not_empty_comma_list<init_declarator>

init_declarator:
    declarator

(* Struct-or-union specifier (used in type_specifier) *)

struct_or_union_specifier:
    struct_or_union IDENTIFIER

struct_or_union:
    STRUCT
    | UNION

(* Enum specifier (used in type_specifier) *)

enum_specifier:
    ENUM IDENTIFIER
    | ENUM IDENTIFIER? '{' enumerator_list ','? '}'

enumerator_list:
    not_empty_comma_list<enumerator>

enumerator:
    IDENTIFIER

(* Common *)

not_empty_comma_list<item>: h=item t=(',' item)* {
    h :: [for (_, it) in t -> it]
}
