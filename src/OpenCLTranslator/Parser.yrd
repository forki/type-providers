{
open Brahma.FSharp.OpenCL.AST
}

tokens {
    _ of string
}

options {
    translate = true
    module = "OpenCLTranslator.Parser"
    infEpsPath = epsilons
    pos = uint64
}

module Main

[<Start>]
program: (* FunDecl list *)
    function_definition+

function_definition: (* FunDecl *)
    declSpecs=declaration_specifier_list clAndIdent=declarator '(' pars=parameter_list ')' ';' {
        let (cl, ident) = clAndIdent
        match cl with
        | None -> FunDecl<Lang>(declSpecs, ident, pars, StatementBlock<_>(new ResizeArray<_>()))
        | Some _ -> failwithf "Fatal: %s is not a valid function declarator" ident // no pointers or arrays allowed
    }

(* Declaration specifiers *)

declaration_specifier_list: (* DeclSpecifierPack *)
    specs=declaration_specifier+ {
        let declPack = new DeclSpecifierPack<_>()
        List.iter (fun f -> f declPack) specs
        declPack
    }

declaration_specifier: (* DeclSpecifierPack -> void *)
    x=function_qualifier {
        fun (declPack:DeclSpecifierPack<_>) ->
            match declPack.FunQual with
            | None -> declPack.FunQual <- Some x
            | Some _ -> failwith "A declaration can't have more than one function qualifier"
    }
    | x=address_space_qualifier {
        fun (declPack:DeclSpecifierPack<_>) ->
            match declPack.AddressSpaceQual with
            | AddressSpaceQualifier.Default -> declPack.AddressSpaceQual <- x
            | _ -> failwith "A declaration can't have more than one address space qualifier"
    }
    | x=access_qualifier {
        fun (declPack:DeclSpecifierPack<_>) ->
            match declPack.AccessQual with
            | None -> declPack.AccessQual <- Some x
            | Some _ -> failwith "A declaration can't have more than one access qualifier"
    }
    | x=storage_class_specifier {
        fun (declPack:DeclSpecifierPack<_>) ->
            match declPack.StorageClassSpec with
            | None -> declPack.StorageClassSpec <- Some x
            | Some _ -> failwith "A declaration can't have more than one storage class specifier"
    }
    | x=type_specifier {
        fun (declPack:DeclSpecifierPack<_>) ->
            match declPack.Type with
            | None -> declPack.Type <- Some x
            | Some _ -> failwith "A declaration can't have more than one type specifier"
    }
    | x=type_qualifier { fun (declPack:DeclSpecifierPack<_>) -> declPack.AddTypeQual x }

function_qualifier: (* FunQualifier *)
    KERNEL { Kernel }

address_space_qualifier: (* AddressSpaceQualifier *)
    GLOBAL { Global }
    | LOCAL { Local }
    | CONSTANT { Constant }
    | PRIVATE { Private }

access_qualifier: (* AccessQualifier *)
    READ_ONLY { ReadOnly }
    | WRITE_ONLY { WriteOnly }
    | READ_WRITE { ReadWrite }

storage_class_specifier: (* StorageClassSpecifier *)
    TYPEDEF { failwith "Fatal: typedef not supported yet!" }
    | EXTERN { Extern }
    | STATIC { Static }

type_specifier: (* Type *)
    t=primitive_type_specifier { t :> Type<_> }
    | s=struct_or_union_specifier { StructType<_>(Some s) :> Type<_> }

primitive_type_specifier: (* PrimitiveType *)
    BOOL { PrimitiveType<_>(Bool) }
    | CHAR { PrimitiveType<_>(Char) } | SHORT { PrimitiveType<_>(Short) }
    | INT { PrimitiveType<_>(Int) } | LONG { PrimitiveType<_>(Long) }
    | UCHAR { PrimitiveType<_>(UChar) } | USHORT { PrimitiveType<_>(UShort) }
    | UINT { PrimitiveType<_>(UInt) } | ULONG { PrimitiveType<_>(ULong) }
    | FLOAT { PrimitiveType<_>(Float) } | DOUBLE { PrimitiveType<_>(Double) } | HALF { PrimitiveType<_>(Half) }
    | SIGNED t=primitive_type_specifier {
        match t with
        | t when (t :? PrimitiveType<_>) ->
            match (t :?> PrimitiveType<_>).Type with
            | Char | Short | Int | Long -> t
            | _ -> t.ToString().ToLower() |> failwithf "Fatal: could not parse \'signed %s\'"
        | _ -> failwith "Fatal: only char, short, int, long can be declared as signed"
    }
    | UNSIGNED t=primitive_type_specifier {
        match t with
        | t when (t :? PrimitiveType<_>) ->
            match (t :?> PrimitiveType<_>).Type with
            | Char -> PrimitiveType<_>(UChar)
            | Short -> PrimitiveType<_>(UShort)
            | Int -> PrimitiveType<_>(UInt)
            | Long -> PrimitiveType<_>(ULong)
            | _ -> t.ToString().ToLower() |> failwithf "Fatal: could not parse \'unsigned %s\'" 
        | _ -> failwith "Fatal: only char, short, int, long can be declared as signed"
    }
    (* | SIZE_T | PTRDIFF_T | INTPTR_T | UINTPTR_T *)
    | VOID { PrimitiveType<_>(Void) }
    (* | CHAR2 | UCHAR2 | SHORT2 | USHORT2 | INT2 | UINT2 | LONG2 | ULONG2 | FLOAT2 | DOUBLE2
    | CHAR3 | UCHAR3 | SHORT3 | USHORT3 | INT3 | UINT3 | LONG3 | ULONG3 | FLOAT3 | DOUBLE3
    | CHAR4 | UCHAR4 | SHORT4 | USHORT4 | INT4 | UINT4 | LONG4 | ULONG4 | FLOAT4 | DOUBLE4
    | CHAR8 | UCHAR8 | SHORT8 | USHORT8 | INT8 | UINT8 | LONG8 | ULONG8 | FLOAT8 | DOUBLE8
    | CHAR16 | UCHAR16 | SHORT16 | USHORT16 | INT16 | UINT16 | LONG16 | ULONG16 | FLOAT16 | DOUBLE16 *)
    (* | IMAGE2D_T | IMAGE3D_T | IMAGE2D_ARRAY_T | IMAGE1D_T
    | IMAGE1D_BUFFER_T | IMAGE1D_ARRAY_T | IMAGE2D_DEPTH_T | IMAGE2D_ARRAY_DEPTH_T *)
    (* | SAMPLER_T | QUEUE_T | NDRANGE_T
    | CLK_EVENT_T | RESERVE_ID_T | EVENT_T
    | CL_MEM_FENCE_FLAGS *)
    | t=TYPE_NAME { PrimitiveType<_>(TypeName t) }
    (* | enum_specifier *)
    (* omitted: reserved data types (OpenCL C 2.0, section 6.1.4) *)

type_qualifier: (* TypeQualifier *)
    CONST { TypeQualifier.Const }
    | RESTRICT { TypeQualifier.Restrict }
    | VOLATILE { TypeQualifier.Volatile }

(* Declarator *)

declarator: (* ((Type -> Type) option, string) *)
    pcl=pointer? dclAndIdent=direct_declarator {
        let (dcl, ident) = dclAndIdent
        match pcl, dcl with
        | None,     None     -> None, ident
        | Some pcl, None     -> Some pcl, ident
        | None,     Some dcl -> Some dcl, ident
        | Some pcl, Some dcl -> Some (pcl >> dcl), ident
    }
(* NB: test the examples from C99, 6.7.5.1.3 at page 115 *)

direct_declarator: (* ((Type -> Type) option, string) *)
    ident=IDENTIFIER { None, ident }
    | clAndIdent=direct_declarator '[' ']' {
        let (cl, ident) = clAndIdent
        match cl with
        | None -> Some (fun t -> ArrayType<_>(t) :> Type<_>), ident
        | Some cl -> Some (fun t -> ArrayType<_>(cl t) :> Type<_>), ident
    }
    (* Pointers to functions are not allowed: OpenCL 2.0, section 6.9.a. *)

pointer: (* Type -> Type *)
    '*' qs=type_qualifier* cl=pointer? {
        match cl with
        | None -> fun t -> new RefType<_>(t, qs) :> Type<_>
        | Some cl -> fun t -> new RefType<_>(cl t, qs) :> Type<_>
    }
    

parameter_list: (* FunFormalArg list *)
    { [] } | not_empty_comma_list<parameter_declaration>

parameter_declaration: (* FunFormalArg *)
    {declSpecs:DeclSpecifierPack<_>}=declaration_specifier_list clAndIdent=declarator {
        let (cl, ident) = clAndIdent
        match cl with
        | None -> FunFormalArg<_>(declSpecs, ident)
        | Some cl ->
            match declSpecs.Type with
            | Some oldType ->
                declSpecs.Type <- Some <| cl oldType
                FunFormalArg<_>(declSpecs, ident)
            | None -> failwithf "Fatal: no type definition found for %s" ident
    }

(* Struct-or-union specifier (used in type_specifier) *)

struct_or_union_specifier: (* Struct *)
    struct_or_union n=IDENTIFIER { Struct<_>(n, []) }

struct_or_union: (* unit *)
    STRUCT
    (* | UNION *)

(* Common *)

not_empty_comma_list<item>: (* item list *)
    h=item t=(',' item)* { h :: [for (_, it) in t -> it] }
